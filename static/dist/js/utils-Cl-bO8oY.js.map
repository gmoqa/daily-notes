{"version":3,"file":"utils-Cl-bO8oY.js","sources":["../../../src/utils/state.ts","../../../src/utils/cache.ts","../../../src/utils/events.ts","../../../src/utils/sync.ts"],"sourcesContent":["/**\n * Mini State Manager\n * Simple reactive state management without a framework\n */\n\nimport type { User, UserSettings, Context, Note } from '@/types'\n\ninterface AppState {\n  // User state\n  currentUser: User | null\n  userSettings: UserSettings\n  hasNoContexts: boolean\n\n  // Selection state\n  selectedContext: string | null\n  selectedDate: string | null\n\n  // Data state\n  contexts: Context[]\n  notes: Note[]\n  notesWithDates: string[]\n\n  // Calendar state\n  currentCalendarMonth: number\n  currentCalendarYear: number\n\n  // UI state\n  isLoggingOut: boolean\n  syncStatus: { pending: number; syncing: boolean }\n\n  // Time\n  serverTimeOffset: number\n}\n\ntype StateKey = keyof AppState\ntype StateListener<K extends StateKey> = (newValue: AppState[K], oldValue: AppState[K]) => void\ntype WildcardListener = (key: StateKey, newValue: any, oldValue: any) => void\ntype ComputedFn<T> = (state: AppState) => T\n\nclass StateManager {\n  private _state: AppState\n  private _listeners: Map<StateKey | '*', Set<StateListener<any> | WildcardListener>>\n  private _computed: Map<string, ComputedFn<any>>\n\n  constructor() {\n    this._state = {\n      // User state\n      currentUser: null,\n      userSettings: {\n        theme: 'dark',\n        weekStart: 0,\n        timezone: 'UTC',\n        dateFormat: 'DD-MM-YY',\n        uniqueContextMode: false,\n        showBreadcrumb: false,\n        showMarkdownEditor: false,\n        hideNewContextButton: false\n      },\n      hasNoContexts: false,\n\n      // Selection state\n      selectedContext: null,\n      selectedDate: null,\n\n      // Data state\n      contexts: [],\n      notes: [],\n      notesWithDates: [],\n\n      // Calendar state\n      currentCalendarMonth: new Date().getMonth(),\n      currentCalendarYear: new Date().getFullYear(),\n\n      // UI state\n      isLoggingOut: false,\n      syncStatus: { pending: 0, syncing: false },\n\n      // Time\n      serverTimeOffset: 0\n    }\n\n    this._listeners = new Map()\n    this._computed = new Map()\n  }\n\n  /**\n   * Get state value\n   */\n  get<K extends StateKey>(key: K): AppState[K]\n  get(key: string): any {\n    if (this._computed.has(key)) {\n      return this._computed.get(key)!(this._state)\n    }\n    return this._state[key as StateKey]\n  }\n\n  /**\n   * Set state value and notify listeners\n   */\n  set<K extends StateKey>(key: K, value: AppState[K]): void {\n    const oldValue = this._state[key]\n    if (oldValue === value) return\n\n    this._state[key] = value\n    this._notify(key, value, oldValue)\n  }\n\n  /**\n   * Update multiple state values at once\n   */\n  update(changes: Partial<AppState>): void {\n    Object.entries(changes).forEach(([key, value]) => {\n      this.set(key as StateKey, value)\n    })\n  }\n\n  /**\n   * Subscribe to state changes\n   */\n  subscribe<K extends StateKey>(key: K, callback: StateListener<K>): () => void\n  subscribe(key: '*', callback: WildcardListener): () => void\n  subscribe(key: StateKey | '*', callback: any): () => void {\n    if (!this._listeners.has(key)) {\n      this._listeners.set(key, new Set())\n    }\n    this._listeners.get(key)!.add(callback)\n\n    // Return unsubscribe function\n    return () => {\n      const listeners = this._listeners.get(key)\n      if (listeners) {\n        listeners.delete(callback)\n      }\n    }\n  }\n\n  /**\n   * Subscribe to multiple keys\n   */\n  subscribeMany(keys: StateKey[], callback: WildcardListener): () => void {\n    const unsubscribers = keys.map(key => this.subscribe(key, callback as any))\n    return () => unsubscribers.forEach(unsub => unsub())\n  }\n\n  /**\n   * Define computed property\n   */\n  computed<T>(key: string, fn: ComputedFn<T>): void {\n    this._computed.set(key, fn)\n  }\n\n  /**\n   * Get entire state (for debugging)\n   */\n  getState(): AppState {\n    return { ...this._state }\n  }\n\n  /**\n   * Notify listeners of change\n   */\n  private _notify<K extends StateKey>(key: K, newValue: AppState[K], oldValue: AppState[K]): void {\n    const listeners = this._listeners.get(key)\n    if (listeners) {\n      listeners.forEach(callback => {\n        try {\n          ;(callback as StateListener<K>)(newValue, oldValue)\n        } catch (error) {\n          console.error(`Error in state listener for \"${key}\":`, error)\n        }\n      })\n    }\n\n    // Notify wildcard listeners (*)\n    const wildcardListeners = this._listeners.get('*')\n    if (wildcardListeners) {\n      wildcardListeners.forEach(callback => {\n        try {\n          ;(callback as WildcardListener)(key, newValue as any, oldValue)\n        } catch (error) {\n          console.error('Error in wildcard state listener:', error)\n        }\n      })\n    }\n  }\n}\n\n// Create singleton instance\nexport const state = new StateManager()\n\n// Setup computed properties\nstate.computed('today', (s) => {\n  const timezone = s.userSettings.timezone || 'UTC'\n  const now = new Date(Date.now() + s.serverTimeOffset)\n\n  const formatter = new Intl.DateTimeFormat('en-US', {\n    timeZone: timezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit'\n  })\n\n  const parts = formatter.formatToParts(now)\n  const year = parts.find(p => p.type === 'year')!.value\n  const month = parts.find(p => p.type === 'month')!.value\n  const day = parts.find(p => p.type === 'day')!.value\n\n  return `${year}-${month}-${day}`\n})\n\n// Debug helper\nif (typeof window !== 'undefined') {\n  ;(window as any).__STATE__ = state\n}\n","/**\n * Local Cache Module\n * IndexedDB-based offline storage for notes and contexts\n */\n\nimport type { Note, Context } from '@/types'\n\ninterface CachedNote extends Note {\n  id: string\n  _localTimestamp: number\n  _cachedAt: number\n}\n\ninterface CachedContext extends Context {\n  _localTimestamp: number\n}\n\nexport class LocalCache {\n  private db: IDBDatabase | null = null\n  private dbName = 'DailyNotesDB'\n  private version = 1\n\n  // Batch write optimization\n  private pendingWrites = new Map<string, CachedNote>()\n  private writeTimer: number | null = null\n  private readonly BATCH_DELAY = 500 // ms\n\n  async init(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version)\n\n      request.onerror = () => reject(request.error)\n\n      request.onsuccess = () => {\n        this.db = request.result\n        resolve()\n      }\n\n      request.onupgradeneeded = (e) => {\n        const db = (e.target as IDBOpenDBRequest).result\n\n        if (!db.objectStoreNames.contains('notes')) {\n          db.createObjectStore('notes', { keyPath: 'id' })\n        }\n\n        if (!db.objectStoreNames.contains('contexts')) {\n          db.createObjectStore('contexts', { keyPath: 'id' })\n        }\n      }\n    })\n  }\n\n  async saveNote(note: Note): Promise<void> {\n    if (!this.db) return\n\n    const id = `${note.context}-${note.date}`\n\n    // Add to pending writes (batching)\n    this.pendingWrites.set(id, {\n      ...note,\n      id,\n      _localTimestamp: Date.now(),\n      _cachedAt: Date.now(),\n      updated_at: note.updated_at || new Date().toISOString()\n    })\n\n    // Schedule batch write\n    this.scheduleBatchWrite()\n  }\n\n  private scheduleBatchWrite(): void {\n    if (this.writeTimer) {\n      clearTimeout(this.writeTimer)\n    }\n\n    this.writeTimer = window.setTimeout(() => {\n      this.flushPendingWrites()\n    }, this.BATCH_DELAY)\n  }\n\n  private async flushPendingWrites(): Promise<void> {\n    if (!this.db || this.pendingWrites.size === 0) return\n\n    const notesToWrite = Array.from(this.pendingWrites.values())\n    this.pendingWrites.clear()\n\n    const tx = this.db.transaction(['notes'], 'readwrite')\n    const store = tx.objectStore('notes')\n\n    notesToWrite.forEach(note => {\n      store.put(note)\n    })\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => {\n        console.log(`[Cache] Batch wrote ${notesToWrite.length} note(s)`)\n        resolve()\n      }\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  // Force immediate write (for critical operations)\n  async saveNoteImmediate(note: Note): Promise<void> {\n    if (!this.db) return\n\n    const tx = this.db.transaction(['notes'], 'readwrite')\n    const store = tx.objectStore('notes')\n    const id = `${note.context}-${note.date}`\n\n    store.put({\n      ...note,\n      id,\n      _localTimestamp: Date.now(),\n      _cachedAt: Date.now(),\n      updated_at: note.updated_at || new Date().toISOString()\n    })\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve()\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  async getNote(context: string, date: string): Promise<CachedNote | null> {\n    if (!this.db) return null\n\n    const tx = this.db.transaction(['notes'], 'readonly')\n    const store = tx.objectStore('notes')\n    const id = `${context}-${date}`\n\n    return new Promise((resolve) => {\n      const request = store.get(id)\n      request.onsuccess = () => resolve(request.result || null)\n      request.onerror = () => resolve(null)\n    })\n  }\n\n  async saveNotes(notes: Note[]): Promise<void> {\n    if (!this.db) return\n\n    const tx = this.db.transaction(['notes'], 'readwrite')\n    const store = tx.objectStore('notes')\n    const now = Date.now()\n\n    notes.forEach(note => {\n      const id = `${note.context}-${note.date}`\n      store.put({\n        ...note,\n        id,\n        _localTimestamp: now,\n        _cachedAt: now,\n        updated_at: note.updated_at || new Date().toISOString()\n      })\n    })\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve()\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  async getNotesByContext(context: string): Promise<CachedNote[]> {\n    if (!this.db) return []\n\n    const tx = this.db.transaction(['notes'], 'readonly')\n    const store = tx.objectStore('notes')\n\n    return new Promise((resolve) => {\n      const request = store.getAll()\n      request.onsuccess = () => {\n        const allNotes = request.result || []\n        resolve(allNotes.filter(n => n.context === context))\n      }\n      request.onerror = () => resolve([])\n    })\n  }\n\n  async saveContexts(contexts: Context[] | null | undefined): Promise<void> {\n    if (!this.db) return\n\n    // Handle null/undefined contexts\n    if (!contexts || !Array.isArray(contexts)) {\n      console.warn('[Cache] saveContexts called with invalid contexts:', contexts)\n      return\n    }\n\n    const tx = this.db.transaction(['contexts'], 'readwrite')\n    const store = tx.objectStore('contexts')\n\n    contexts.forEach(ctx => {\n      store.put({\n        ...ctx,\n        _localTimestamp: Date.now()\n      })\n    })\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve()\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  async getContexts(): Promise<CachedContext[]> {\n    if (!this.db) return []\n\n    const tx = this.db.transaction(['contexts'], 'readonly')\n    const store = tx.objectStore('contexts')\n\n    return new Promise((resolve) => {\n      const request = store.getAll()\n      request.onsuccess = () => resolve(request.result || [])\n      request.onerror = () => resolve([])\n    })\n  }\n\n  async deleteNote(context: string, date: string): Promise<void> {\n    if (!this.db) return\n\n    const id = `${context}-${date}`\n\n    // Remove from pending writes if it's there\n    this.pendingWrites.delete(id)\n\n    const tx = this.db.transaction(['notes'], 'readwrite')\n    const store = tx.objectStore('notes')\n\n    store.delete(id)\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => {\n        console.log(`[Cache] Deleted note: ${id}`)\n        resolve()\n      }\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  async clear(): Promise<void> {\n    if (!this.db) return\n\n    const tx = this.db.transaction(['notes', 'contexts'], 'readwrite')\n\n    tx.objectStore('notes').clear()\n    tx.objectStore('contexts').clear()\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve()\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n}\n\n// Create singleton instance\nexport const cache = new LocalCache()\n","/**\n * Event Bus\n * Central event system for app-wide communication\n */\n\n// Event detail types\ninterface NoteEventDetail {\n  context: string\n  date: string\n  content?: string\n}\n\ninterface SyncStatusDetail {\n  pending: number\n  syncing: boolean\n}\n\ninterface ErrorEventDetail {\n  message: string\n  error?: Error\n}\n\ninterface SuccessEventDetail {\n  message: string\n}\n\n// Event type mapping\ninterface EventTypeMap {\n  // Notes\n  'note-cached': NoteEventDetail\n  'note-loaded': NoteEventDetail\n  'note-saved': NoteEventDetail\n  'note-changed': NoteEventDetail\n\n  // Sync\n  'sync-status': SyncStatusDetail\n  'operation-synced': { operationId: string }\n  'sync-error': ErrorEventDetail\n\n  // Context\n  'context-changed': { context: string | null }\n  'contexts-loaded': { contexts: any[] }\n\n  // Date\n  'date-changed': { date: string }\n\n  // UI\n  'show-error': ErrorEventDetail\n  'show-success': SuccessEventDetail\n}\n\ntype EventName = keyof EventTypeMap\ntype EventDetail<T extends EventName> = EventTypeMap[T]\n\nclass EventBus extends EventTarget {\n  /**\n   * Emit a typed event\n   */\n  emit<T extends EventName>(eventName: T, detail: EventDetail<T>): void {\n    this.dispatchEvent(new CustomEvent(eventName, { detail }))\n  }\n\n  /**\n   * Listen to a typed event\n   */\n  on<T extends EventName>(\n    eventName: T,\n    callback: (event: CustomEvent<EventDetail<T>>) => void\n  ): () => void {\n    const listener = callback as EventListener\n    this.addEventListener(eventName, listener)\n    return () => this.removeEventListener(eventName, listener)\n  }\n\n  /**\n   * Listen to an event once\n   */\n  once<T extends EventName>(\n    eventName: T,\n    callback: (event: CustomEvent<EventDetail<T>>) => void\n  ): () => void {\n    const listener = callback as EventListener\n    const handler = (event: Event) => {\n      listener(event)\n      this.removeEventListener(eventName, handler)\n    }\n    this.addEventListener(eventName, handler)\n    return () => this.removeEventListener(eventName, handler)\n  }\n}\n\nexport const events = new EventBus()\n\n// Event names for easy reference and autocomplete\nexport const EVENT = {\n  // Notes\n  NOTE_CACHED: 'note-cached' as const,\n  NOTE_LOADED: 'note-loaded' as const,\n  NOTE_SAVED: 'note-saved' as const,\n  NOTE_CHANGED: 'note-changed' as const,\n\n  // Sync\n  SYNC_STATUS: 'sync-status' as const,\n  OPERATION_SYNCED: 'operation-synced' as const,\n  SYNC_ERROR: 'sync-error' as const,\n\n  // Context\n  CONTEXT_CHANGED: 'context-changed' as const,\n  CONTEXTS_LOADED: 'contexts-loaded' as const,\n\n  // Date\n  DATE_CHANGED: 'date-changed' as const,\n\n  // UI\n  SHOW_ERROR: 'show-error' as const,\n  SHOW_SUCCESS: 'show-success' as const\n} as const\n","/**\n * Sync Queue Module\n * Handles background synchronization with retry logic\n */\n\nimport { events, EVENT } from './events'\nimport type { APIClient } from '../services/api'\n\nexport interface SyncOperation {\n  id?: number\n  type: 'save-note' | 'delete-note' | 'create-context'\n  data: any\n}\n\nexport interface SyncStats {\n  queueSize: number\n  processing: boolean\n  failedOperations: number\n  retryDelay: number\n}\n\nexport class SyncQueue {\n  private api: APIClient\n  private queue: SyncOperation[] = []\n  private processing = false\n  private retryDelay = 2000\n  private readonly maxRetryDelay = 30000\n  private batchTimer: NodeJS.Timeout | null = null\n  private readonly batchDelay = 15000 // 15 seconds\n  private failedOperations = new Map<string, number>()\n  private readonly maxRetries = 3\n\n  constructor(api: APIClient) {\n    this.api = api\n  }\n\n  add(operation: SyncOperation): void {\n    console.log('[Sync] Adding operation to queue:', operation.type, operation.data)\n\n    // Check if we already have a pending operation for this note\n    if (operation.type === 'save-note') {\n      const existingIndex = this.queue.findIndex(\n        op =>\n          op.type === 'save-note' &&\n          op.data.context === operation.data.context &&\n          op.data.date === operation.data.date\n      )\n\n      if (existingIndex !== -1) {\n        // Update existing operation instead of adding new one\n        this.queue[existingIndex] = { ...operation, id: Date.now() + Math.random() }\n        console.log('[Sync] Updated existing save operation in queue')\n      } else {\n        this.queue.push({ ...operation, id: Date.now() + Math.random() })\n        console.log('[Sync] Added new save operation to queue')\n      }\n    } else if (operation.type === 'delete-note') {\n      // Remove any pending save operations for this note\n      const beforeLength = this.queue.length\n      this.queue = this.queue.filter(\n        op =>\n          !(\n            op.type === 'save-note' &&\n            op.data.context === operation.data.context &&\n            op.data.date === operation.data.date\n          )\n      )\n      const removedCount = beforeLength - this.queue.length\n      if (removedCount > 0) {\n        console.log(`[Sync] Removed ${removedCount} pending save operations for this note`)\n      }\n      // Add the delete operation\n      this.queue.push({ ...operation, id: Date.now() + Math.random() })\n      console.log('[Sync] Added delete operation to queue')\n\n      // Process delete operations immediately (no batching delay)\n      console.log('[Sync] Delete operation detected, processing immediately')\n      this.processImmediate()\n      return\n    } else {\n      this.queue.push({ ...operation, id: Date.now() + Math.random() })\n      console.log('[Sync] Added operation to queue')\n    }\n\n    console.log('[Sync] Queue size:', this.queue.length)\n    this.updateUI()\n    this.scheduleBatch()\n  }\n\n  private scheduleBatch(): void {\n    // Clear existing timer\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n    }\n\n    // Schedule batch processing after delay\n    console.log(`[Sync] Scheduling batch processing in ${this.batchDelay}ms`)\n    this.batchTimer = setTimeout(() => {\n      console.log('[Sync] Batch timer triggered, starting process')\n      this.process()\n    }, this.batchDelay)\n  }\n\n  processImmediate(): void {\n    // Clear any pending batch timer\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n      this.batchTimer = null\n    }\n\n    // Process immediately without delay\n    console.log('[Sync] Processing queue immediately')\n    this.updateUI()\n    this.process()\n  }\n\n  private updateUI(): void {\n    const pending = this.queue.length\n    events.emit(EVENT.SYNC_STATUS, {\n      pending,\n      syncing: this.processing\n    })\n  }\n\n  async process(): Promise<void> {\n    if (this.processing || this.queue.length === 0) return\n\n    this.processing = true\n    this.batchTimer = null\n    this.updateUI()\n\n    while (this.queue.length > 0) {\n      const op = this.queue[0]\n      if (!op) break // Guard against undefined\n\n      const opKey = this.getOperationKey(op)\n\n      try {\n        await this.executeOperation(op)\n\n        // Success - remove from queue and failed operations\n        this.queue.shift()\n        this.failedOperations.delete(opKey)\n\n        events.emit(EVENT.OPERATION_SYNCED, { operationId: String(op.id || opKey) })\n        console.log('[Sync] Successfully synced:', op.type, opKey)\n        this.updateUI()\n\n        // Reset retry delay on success\n        this.retryDelay = 2000\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err))\n        console.warn('[Sync] Failed to sync operation:', error)\n\n        // Check if this is a session expired error\n        if (error.message.includes('Session expired')) {\n          console.log('[Sync] Session expired, keeping operations in queue for later')\n          // Don't remove from queue, will retry after re-login\n          break\n        }\n\n        // Track retry count\n        const retryCount = (this.failedOperations.get(opKey) || 0) + 1\n        this.failedOperations.set(opKey, retryCount)\n\n        if (retryCount >= this.maxRetries) {\n          // Max retries reached - remove from queue\n          console.error(`[Sync] Max retries (${this.maxRetries}) reached for operation:`, opKey)\n          this.queue.shift()\n          this.failedOperations.delete(opKey)\n\n          events.emit(EVENT.SYNC_ERROR, {\n            message: error.message,\n            maxRetriesReached: true\n          } as any)\n        } else {\n          // Retry with exponential backoff\n          console.log(`[Sync] Retry ${retryCount}/${this.maxRetries} for operation:`, opKey)\n          events.emit(EVENT.SYNC_ERROR, {\n            message: error.message,\n            retryCount,\n            maxRetries: this.maxRetries\n          } as any)\n\n          await new Promise(resolve => setTimeout(resolve, this.retryDelay))\n          this.retryDelay = Math.min(this.retryDelay * 1.5, this.maxRetryDelay)\n        }\n      }\n    }\n\n    this.processing = false\n    this.retryDelay = 2000\n    this.updateUI()\n  }\n\n  private getOperationKey(op: SyncOperation): string {\n    if (op.type === 'save-note' || op.type === 'delete-note') {\n      return `${op.type}-${op.data.context}-${op.data.date}`\n    }\n    return `${op.type}-${op.id}`\n  }\n\n  private async executeOperation(op: SyncOperation): Promise<any> {\n    console.log('[Sync] Executing operation:', op.type, op.data)\n\n    switch (op.type) {\n      case 'save-note':\n        console.log('[Sync] Calling API saveNote')\n        return await this.api.saveNote(op.data)\n\n      case 'delete-note':\n        console.log(\n          '[Sync] Calling API deleteNote with context:',\n          op.data.context,\n          'date:',\n          op.data.date\n        )\n        const result = await this.api.deleteNote(op.data.context, op.data.date)\n        console.log('[Sync] API deleteNote result:', result)\n        return result\n\n      case 'create-context':\n        console.log('[Sync] Calling API createContext')\n        return await this.api.createContext(op.data)\n\n      default:\n        throw new Error('Unknown operation type')\n    }\n  }\n\n  getPendingCount(): number {\n    return this.queue.length\n  }\n\n  clear(): void {\n    this.queue = []\n    this.failedOperations.clear()\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n      this.batchTimer = null\n    }\n    this.updateUI()\n  }\n\n  // Get statistics for debugging\n  getStats(): SyncStats {\n    return {\n      queueSize: this.queue.length,\n      processing: this.processing,\n      failedOperations: this.failedOperations.size,\n      retryDelay: this.retryDelay\n    }\n  }\n}\n"],"names":["state","constructor","__publicField","this","_state","currentUser","userSettings","theme","weekStart","timezone","dateFormat","uniqueContextMode","showBreadcrumb","showMarkdownEditor","hideNewContextButton","hasNoContexts","selectedContext","selectedDate","contexts","notes","notesWithDates","currentCalendarMonth","Date","getMonth","currentCalendarYear","getFullYear","isLoggingOut","syncStatus","pending","syncing","serverTimeOffset","_listeners","Map","_computed","get","key","has","set","value","oldValue","_notify","update","changes","Object","entries","forEach","subscribe","callback","Set","add","listeners","delete","subscribeMany","keys","unsubscribers","map","unsub","computed","fn","getState","newValue","error","console","concat","wildcardListeners","s","now","parts","Intl","DateTimeFormat","timeZone","year","month","day","formatToParts","find","p","type","window","__STATE__","cache","init","Promise","resolve","reject","request","indexedDB","open","dbName","version","onerror","onsuccess","db","result","onupgradeneeded","e","target","objectStoreNames","contains","createObjectStore","keyPath","saveNote","note","id","context","date","pendingWrites","_localTimestamp","_cachedAt","updated_at","toISOString","scheduleBatchWrite","writeTimer","clearTimeout","setTimeout","flushPendingWrites","BATCH_DELAY","size","notesToWrite","Array","from","values","clear","tx","transaction","store","objectStore","put","oncomplete","log","length","saveNoteImmediate","getNote","saveNotes","getNotesByContext","getAll","allNotes","filter","n","saveContexts","isArray","warn","ctx","getContexts","deleteNote","EventBus","EventTarget","emit","eventName","detail","dispatchEvent","CustomEvent","on","listener","addEventListener","removeEventListener","once","handler","event","events","EVENT","NOTE_CACHED","NOTE_LOADED","NOTE_SAVED","NOTE_CHANGED","SYNC_STATUS","OPERATION_SYNCED","SYNC_ERROR","CONTEXT_CHANGED","CONTEXTS_LOADED","DATE_CHANGED","SHOW_ERROR","SHOW_SUCCESS","SyncQueue","api","operation","data","existingIndex","queue","findIndex","op","Math","random","push","beforeLength","removedCount","processImmediate","updateUI","scheduleBatch","batchTimer","batchDelay","process","processing","opKey","getOperationKey","executeOperation","shift","failedOperations","operationId","String","retryDelay","err","Error","message","includes","retryCount","maxRetries","maxRetriesReached","min","maxRetryDelay","createContext","getPendingCount","getStats","queueSize"],"mappings":"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"}