{"version":3,"file":"utils-legacy-DjbRq7fS.js","sources":["../../../src/utils/state.ts","../../../src/utils/cache.ts","../../../src/utils/events.ts","../../../src/utils/sync.ts"],"sourcesContent":["/**\n * Mini State Manager\n * Simple reactive state management without a framework\n */\n\nimport type { User, UserSettings, Context, Note } from '@/types'\n\ninterface AppState {\n  // User state\n  currentUser: User | null\n  userSettings: UserSettings\n  hasNoContexts: boolean\n\n  // Selection state\n  selectedContext: string | null\n  selectedDate: string | null\n\n  // Data state\n  contexts: Context[]\n  notes: Note[]\n  notesWithDates: string[]\n\n  // Calendar state\n  currentCalendarMonth: number\n  currentCalendarYear: number\n\n  // UI state\n  isLoggingOut: boolean\n  syncStatus: { pending: number; syncing: boolean }\n\n  // Time\n  serverTimeOffset: number\n}\n\ntype StateKey = keyof AppState\ntype StateListener<K extends StateKey> = (newValue: AppState[K], oldValue: AppState[K]) => void\ntype WildcardListener = (key: StateKey, newValue: any, oldValue: any) => void\ntype ComputedFn<T> = (state: AppState) => T\n\nclass StateManager {\n  private _state: AppState\n  private _listeners: Map<StateKey | '*', Set<StateListener<any> | WildcardListener>>\n  private _computed: Map<string, ComputedFn<any>>\n\n  constructor() {\n    this._state = {\n      // User state\n      currentUser: null,\n      userSettings: {\n        theme: 'dark',\n        weekStart: 0,\n        timezone: 'UTC',\n        dateFormat: 'DD-MM-YY',\n        uniqueContextMode: false,\n        showBreadcrumb: false,\n        showMarkdownEditor: false,\n        hideNewContextButton: false\n      },\n      hasNoContexts: false,\n\n      // Selection state\n      selectedContext: null,\n      selectedDate: null,\n\n      // Data state\n      contexts: [],\n      notes: [],\n      notesWithDates: [],\n\n      // Calendar state\n      currentCalendarMonth: new Date().getMonth(),\n      currentCalendarYear: new Date().getFullYear(),\n\n      // UI state\n      isLoggingOut: false,\n      syncStatus: { pending: 0, syncing: false },\n\n      // Time\n      serverTimeOffset: 0\n    }\n\n    this._listeners = new Map()\n    this._computed = new Map()\n  }\n\n  /**\n   * Get state value\n   */\n  get<K extends StateKey>(key: K): AppState[K]\n  get(key: string): any {\n    if (this._computed.has(key)) {\n      return this._computed.get(key)!(this._state)\n    }\n    return this._state[key as StateKey]\n  }\n\n  /**\n   * Set state value and notify listeners\n   */\n  set<K extends StateKey>(key: K, value: AppState[K]): void {\n    const oldValue = this._state[key]\n    if (oldValue === value) return\n\n    this._state[key] = value\n    this._notify(key, value, oldValue)\n  }\n\n  /**\n   * Update multiple state values at once\n   */\n  update(changes: Partial<AppState>): void {\n    Object.entries(changes).forEach(([key, value]) => {\n      this.set(key as StateKey, value)\n    })\n  }\n\n  /**\n   * Subscribe to state changes\n   */\n  subscribe<K extends StateKey>(key: K, callback: StateListener<K>): () => void\n  subscribe(key: '*', callback: WildcardListener): () => void\n  subscribe(key: StateKey | '*', callback: any): () => void {\n    if (!this._listeners.has(key)) {\n      this._listeners.set(key, new Set())\n    }\n    this._listeners.get(key)!.add(callback)\n\n    // Return unsubscribe function\n    return () => {\n      const listeners = this._listeners.get(key)\n      if (listeners) {\n        listeners.delete(callback)\n      }\n    }\n  }\n\n  /**\n   * Subscribe to multiple keys\n   */\n  subscribeMany(keys: StateKey[], callback: WildcardListener): () => void {\n    const unsubscribers = keys.map(key => this.subscribe(key, callback as any))\n    return () => unsubscribers.forEach(unsub => unsub())\n  }\n\n  /**\n   * Define computed property\n   */\n  computed<T>(key: string, fn: ComputedFn<T>): void {\n    this._computed.set(key, fn)\n  }\n\n  /**\n   * Get entire state (for debugging)\n   */\n  getState(): AppState {\n    return { ...this._state }\n  }\n\n  /**\n   * Notify listeners of change\n   */\n  private _notify<K extends StateKey>(key: K, newValue: AppState[K], oldValue: AppState[K]): void {\n    const listeners = this._listeners.get(key)\n    if (listeners) {\n      listeners.forEach(callback => {\n        try {\n          ;(callback as StateListener<K>)(newValue, oldValue)\n        } catch (error) {\n          console.error(`Error in state listener for \"${key}\":`, error)\n        }\n      })\n    }\n\n    // Notify wildcard listeners (*)\n    const wildcardListeners = this._listeners.get('*')\n    if (wildcardListeners) {\n      wildcardListeners.forEach(callback => {\n        try {\n          ;(callback as WildcardListener)(key, newValue as any, oldValue)\n        } catch (error) {\n          console.error('Error in wildcard state listener:', error)\n        }\n      })\n    }\n  }\n}\n\n// Create singleton instance\nexport const state = new StateManager()\n\n// Setup computed properties\nstate.computed('today', (s) => {\n  const timezone = s.userSettings.timezone || 'UTC'\n  const now = new Date(Date.now() + s.serverTimeOffset)\n\n  const formatter = new Intl.DateTimeFormat('en-US', {\n    timeZone: timezone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit'\n  })\n\n  const parts = formatter.formatToParts(now)\n  const year = parts.find(p => p.type === 'year')!.value\n  const month = parts.find(p => p.type === 'month')!.value\n  const day = parts.find(p => p.type === 'day')!.value\n\n  return `${year}-${month}-${day}`\n})\n\n// Debug helper\nif (typeof window !== 'undefined') {\n  ;(window as any).__STATE__ = state\n}\n","/**\n * Local Cache Module\n * IndexedDB-based offline storage for notes and contexts\n */\n\nimport type { Note, Context } from '@/types'\n\ninterface CachedNote extends Note {\n  id: string\n  _localTimestamp: number\n  _cachedAt: number\n}\n\ninterface CachedContext extends Context {\n  _localTimestamp: number\n}\n\nexport class LocalCache {\n  private db: IDBDatabase | null = null\n  private dbName = 'DailyNotesDB'\n  private version = 1\n\n  // Batch write optimization\n  private pendingWrites = new Map<string, CachedNote>()\n  private writeTimer: number | null = null\n  private readonly BATCH_DELAY = 500 // ms\n\n  async init(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version)\n\n      request.onerror = () => reject(request.error)\n\n      request.onsuccess = () => {\n        this.db = request.result\n        resolve()\n      }\n\n      request.onupgradeneeded = (e) => {\n        const db = (e.target as IDBOpenDBRequest).result\n\n        if (!db.objectStoreNames.contains('notes')) {\n          db.createObjectStore('notes', { keyPath: 'id' })\n        }\n\n        if (!db.objectStoreNames.contains('contexts')) {\n          db.createObjectStore('contexts', { keyPath: 'id' })\n        }\n      }\n    })\n  }\n\n  async saveNote(note: Note): Promise<void> {\n    if (!this.db) return\n\n    const id = `${note.context}-${note.date}`\n\n    // Add to pending writes (batching)\n    this.pendingWrites.set(id, {\n      ...note,\n      id,\n      _localTimestamp: Date.now(),\n      _cachedAt: Date.now(),\n      updated_at: note.updated_at || new Date().toISOString()\n    })\n\n    // Schedule batch write\n    this.scheduleBatchWrite()\n  }\n\n  private scheduleBatchWrite(): void {\n    if (this.writeTimer) {\n      clearTimeout(this.writeTimer)\n    }\n\n    this.writeTimer = window.setTimeout(() => {\n      this.flushPendingWrites()\n    }, this.BATCH_DELAY)\n  }\n\n  private async flushPendingWrites(): Promise<void> {\n    if (!this.db || this.pendingWrites.size === 0) return\n\n    const notesToWrite = Array.from(this.pendingWrites.values())\n    this.pendingWrites.clear()\n\n    const tx = this.db.transaction(['notes'], 'readwrite')\n    const store = tx.objectStore('notes')\n\n    notesToWrite.forEach(note => {\n      store.put(note)\n    })\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => {\n        console.log(`[Cache] Batch wrote ${notesToWrite.length} note(s)`)\n        resolve()\n      }\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  // Force immediate write (for critical operations)\n  async saveNoteImmediate(note: Note): Promise<void> {\n    if (!this.db) return\n\n    const tx = this.db.transaction(['notes'], 'readwrite')\n    const store = tx.objectStore('notes')\n    const id = `${note.context}-${note.date}`\n\n    store.put({\n      ...note,\n      id,\n      _localTimestamp: Date.now(),\n      _cachedAt: Date.now(),\n      updated_at: note.updated_at || new Date().toISOString()\n    })\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve()\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  async getNote(context: string, date: string): Promise<CachedNote | null> {\n    if (!this.db) return null\n\n    const tx = this.db.transaction(['notes'], 'readonly')\n    const store = tx.objectStore('notes')\n    const id = `${context}-${date}`\n\n    return new Promise((resolve) => {\n      const request = store.get(id)\n      request.onsuccess = () => resolve(request.result || null)\n      request.onerror = () => resolve(null)\n    })\n  }\n\n  async saveNotes(notes: Note[]): Promise<void> {\n    if (!this.db) return\n\n    const tx = this.db.transaction(['notes'], 'readwrite')\n    const store = tx.objectStore('notes')\n    const now = Date.now()\n\n    notes.forEach(note => {\n      const id = `${note.context}-${note.date}`\n      store.put({\n        ...note,\n        id,\n        _localTimestamp: now,\n        _cachedAt: now,\n        updated_at: note.updated_at || new Date().toISOString()\n      })\n    })\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve()\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  async getNotesByContext(context: string): Promise<CachedNote[]> {\n    if (!this.db) return []\n\n    const tx = this.db.transaction(['notes'], 'readonly')\n    const store = tx.objectStore('notes')\n\n    return new Promise((resolve) => {\n      const request = store.getAll()\n      request.onsuccess = () => {\n        const allNotes = request.result || []\n        resolve(allNotes.filter(n => n.context === context))\n      }\n      request.onerror = () => resolve([])\n    })\n  }\n\n  async saveContexts(contexts: Context[] | null | undefined): Promise<void> {\n    if (!this.db) return\n\n    // Handle null/undefined contexts\n    if (!contexts || !Array.isArray(contexts)) {\n      console.warn('[Cache] saveContexts called with invalid contexts:', contexts)\n      return\n    }\n\n    const tx = this.db.transaction(['contexts'], 'readwrite')\n    const store = tx.objectStore('contexts')\n\n    contexts.forEach(ctx => {\n      store.put({\n        ...ctx,\n        _localTimestamp: Date.now()\n      })\n    })\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve()\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  async getContexts(): Promise<CachedContext[]> {\n    if (!this.db) return []\n\n    const tx = this.db.transaction(['contexts'], 'readonly')\n    const store = tx.objectStore('contexts')\n\n    return new Promise((resolve) => {\n      const request = store.getAll()\n      request.onsuccess = () => resolve(request.result || [])\n      request.onerror = () => resolve([])\n    })\n  }\n\n  async deleteNote(context: string, date: string): Promise<void> {\n    if (!this.db) return\n\n    const id = `${context}-${date}`\n\n    // Remove from pending writes if it's there\n    this.pendingWrites.delete(id)\n\n    const tx = this.db.transaction(['notes'], 'readwrite')\n    const store = tx.objectStore('notes')\n\n    store.delete(id)\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => {\n        console.log(`[Cache] Deleted note: ${id}`)\n        resolve()\n      }\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n\n  async clear(): Promise<void> {\n    if (!this.db) return\n\n    const tx = this.db.transaction(['notes', 'contexts'], 'readwrite')\n\n    tx.objectStore('notes').clear()\n    tx.objectStore('contexts').clear()\n\n    return new Promise((resolve, reject) => {\n      tx.oncomplete = () => resolve()\n      tx.onerror = () => reject(tx.error)\n    })\n  }\n}\n\n// Create singleton instance\nexport const cache = new LocalCache()\n","/**\n * Event Bus\n * Central event system for app-wide communication\n */\n\n// Event detail types\ninterface NoteEventDetail {\n  context: string\n  date: string\n  content?: string\n}\n\ninterface SyncStatusDetail {\n  pending: number\n  syncing: boolean\n}\n\ninterface ErrorEventDetail {\n  message: string\n  error?: Error\n}\n\ninterface SuccessEventDetail {\n  message: string\n}\n\n// Event type mapping\ninterface EventTypeMap {\n  // Notes\n  'note-cached': NoteEventDetail\n  'note-loaded': NoteEventDetail\n  'note-saved': NoteEventDetail\n  'note-changed': NoteEventDetail\n\n  // Sync\n  'sync-status': SyncStatusDetail\n  'operation-synced': { operationId: string }\n  'sync-error': ErrorEventDetail\n\n  // Context\n  'context-changed': { context: string | null }\n  'contexts-loaded': { contexts: any[] }\n\n  // Date\n  'date-changed': { date: string }\n\n  // UI\n  'show-error': ErrorEventDetail\n  'show-success': SuccessEventDetail\n}\n\ntype EventName = keyof EventTypeMap\ntype EventDetail<T extends EventName> = EventTypeMap[T]\n\nclass EventBus extends EventTarget {\n  /**\n   * Emit a typed event\n   */\n  emit<T extends EventName>(eventName: T, detail: EventDetail<T>): void {\n    this.dispatchEvent(new CustomEvent(eventName, { detail }))\n  }\n\n  /**\n   * Listen to a typed event\n   */\n  on<T extends EventName>(\n    eventName: T,\n    callback: (event: CustomEvent<EventDetail<T>>) => void\n  ): () => void {\n    const listener = callback as EventListener\n    this.addEventListener(eventName, listener)\n    return () => this.removeEventListener(eventName, listener)\n  }\n\n  /**\n   * Listen to an event once\n   */\n  once<T extends EventName>(\n    eventName: T,\n    callback: (event: CustomEvent<EventDetail<T>>) => void\n  ): () => void {\n    const listener = callback as EventListener\n    const handler = (event: Event) => {\n      listener(event)\n      this.removeEventListener(eventName, handler)\n    }\n    this.addEventListener(eventName, handler)\n    return () => this.removeEventListener(eventName, handler)\n  }\n}\n\nexport const events = new EventBus()\n\n// Event names for easy reference and autocomplete\nexport const EVENT = {\n  // Notes\n  NOTE_CACHED: 'note-cached' as const,\n  NOTE_LOADED: 'note-loaded' as const,\n  NOTE_SAVED: 'note-saved' as const,\n  NOTE_CHANGED: 'note-changed' as const,\n\n  // Sync\n  SYNC_STATUS: 'sync-status' as const,\n  OPERATION_SYNCED: 'operation-synced' as const,\n  SYNC_ERROR: 'sync-error' as const,\n\n  // Context\n  CONTEXT_CHANGED: 'context-changed' as const,\n  CONTEXTS_LOADED: 'contexts-loaded' as const,\n\n  // Date\n  DATE_CHANGED: 'date-changed' as const,\n\n  // UI\n  SHOW_ERROR: 'show-error' as const,\n  SHOW_SUCCESS: 'show-success' as const\n} as const\n","/**\n * Sync Queue Module\n * Handles background synchronization with retry logic\n */\n\nimport { events, EVENT } from './events'\nimport type { APIClient } from '../services/api'\n\nexport interface SyncOperation {\n  id?: number\n  type: 'save-note' | 'delete-note' | 'create-context'\n  data: any\n}\n\nexport interface SyncStats {\n  queueSize: number\n  processing: boolean\n  failedOperations: number\n  retryDelay: number\n}\n\nexport class SyncQueue {\n  private api: APIClient\n  private queue: SyncOperation[] = []\n  private processing = false\n  private retryDelay = 2000\n  private readonly maxRetryDelay = 30000\n  private batchTimer: NodeJS.Timeout | null = null\n  private readonly batchDelay = 15000 // 15 seconds\n  private failedOperations = new Map<string, number>()\n  private readonly maxRetries = 3\n\n  constructor(api: APIClient) {\n    this.api = api\n  }\n\n  add(operation: SyncOperation): void {\n    console.log('[Sync] Adding operation to queue:', operation.type, operation.data)\n\n    // Check if we already have a pending operation for this note\n    if (operation.type === 'save-note') {\n      const existingIndex = this.queue.findIndex(\n        op =>\n          op.type === 'save-note' &&\n          op.data.context === operation.data.context &&\n          op.data.date === operation.data.date\n      )\n\n      if (existingIndex !== -1) {\n        // Update existing operation instead of adding new one\n        this.queue[existingIndex] = { ...operation, id: Date.now() + Math.random() }\n        console.log('[Sync] Updated existing save operation in queue')\n      } else {\n        this.queue.push({ ...operation, id: Date.now() + Math.random() })\n        console.log('[Sync] Added new save operation to queue')\n      }\n    } else if (operation.type === 'delete-note') {\n      // Remove any pending save operations for this note\n      const beforeLength = this.queue.length\n      this.queue = this.queue.filter(\n        op =>\n          !(\n            op.type === 'save-note' &&\n            op.data.context === operation.data.context &&\n            op.data.date === operation.data.date\n          )\n      )\n      const removedCount = beforeLength - this.queue.length\n      if (removedCount > 0) {\n        console.log(`[Sync] Removed ${removedCount} pending save operations for this note`)\n      }\n      // Add the delete operation\n      this.queue.push({ ...operation, id: Date.now() + Math.random() })\n      console.log('[Sync] Added delete operation to queue')\n\n      // Process delete operations immediately (no batching delay)\n      console.log('[Sync] Delete operation detected, processing immediately')\n      this.processImmediate()\n      return\n    } else {\n      this.queue.push({ ...operation, id: Date.now() + Math.random() })\n      console.log('[Sync] Added operation to queue')\n    }\n\n    console.log('[Sync] Queue size:', this.queue.length)\n    this.updateUI()\n    this.scheduleBatch()\n  }\n\n  private scheduleBatch(): void {\n    // Clear existing timer\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n    }\n\n    // Schedule batch processing after delay\n    console.log(`[Sync] Scheduling batch processing in ${this.batchDelay}ms`)\n    this.batchTimer = setTimeout(() => {\n      console.log('[Sync] Batch timer triggered, starting process')\n      this.process()\n    }, this.batchDelay)\n  }\n\n  processImmediate(): void {\n    // Clear any pending batch timer\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n      this.batchTimer = null\n    }\n\n    // Process immediately without delay\n    console.log('[Sync] Processing queue immediately')\n    this.updateUI()\n    this.process()\n  }\n\n  private updateUI(): void {\n    const pending = this.queue.length\n    events.emit(EVENT.SYNC_STATUS, {\n      pending,\n      syncing: this.processing\n    })\n  }\n\n  async process(): Promise<void> {\n    if (this.processing || this.queue.length === 0) return\n\n    this.processing = true\n    this.batchTimer = null\n    this.updateUI()\n\n    while (this.queue.length > 0) {\n      const op = this.queue[0]\n      if (!op) break // Guard against undefined\n\n      const opKey = this.getOperationKey(op)\n\n      try {\n        await this.executeOperation(op)\n\n        // Success - remove from queue and failed operations\n        this.queue.shift()\n        this.failedOperations.delete(opKey)\n\n        events.emit(EVENT.OPERATION_SYNCED, { operationId: String(op.id || opKey) })\n        console.log('[Sync] Successfully synced:', op.type, opKey)\n        this.updateUI()\n\n        // Reset retry delay on success\n        this.retryDelay = 2000\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err))\n        console.warn('[Sync] Failed to sync operation:', error)\n\n        // Check if this is a session expired error\n        if (error.message.includes('Session expired')) {\n          console.log('[Sync] Session expired, keeping operations in queue for later')\n          // Don't remove from queue, will retry after re-login\n          break\n        }\n\n        // Track retry count\n        const retryCount = (this.failedOperations.get(opKey) || 0) + 1\n        this.failedOperations.set(opKey, retryCount)\n\n        if (retryCount >= this.maxRetries) {\n          // Max retries reached - remove from queue\n          console.error(`[Sync] Max retries (${this.maxRetries}) reached for operation:`, opKey)\n          this.queue.shift()\n          this.failedOperations.delete(opKey)\n\n          events.emit(EVENT.SYNC_ERROR, {\n            message: error.message,\n            maxRetriesReached: true\n          } as any)\n        } else {\n          // Retry with exponential backoff\n          console.log(`[Sync] Retry ${retryCount}/${this.maxRetries} for operation:`, opKey)\n          events.emit(EVENT.SYNC_ERROR, {\n            message: error.message,\n            retryCount,\n            maxRetries: this.maxRetries\n          } as any)\n\n          await new Promise(resolve => setTimeout(resolve, this.retryDelay))\n          this.retryDelay = Math.min(this.retryDelay * 1.5, this.maxRetryDelay)\n        }\n      }\n    }\n\n    this.processing = false\n    this.retryDelay = 2000\n    this.updateUI()\n  }\n\n  private getOperationKey(op: SyncOperation): string {\n    if (op.type === 'save-note' || op.type === 'delete-note') {\n      return `${op.type}-${op.data.context}-${op.data.date}`\n    }\n    return `${op.type}-${op.id}`\n  }\n\n  private async executeOperation(op: SyncOperation): Promise<any> {\n    console.log('[Sync] Executing operation:', op.type, op.data)\n\n    switch (op.type) {\n      case 'save-note':\n        console.log('[Sync] Calling API saveNote')\n        return await this.api.saveNote(op.data)\n\n      case 'delete-note':\n        console.log(\n          '[Sync] Calling API deleteNote with context:',\n          op.data.context,\n          'date:',\n          op.data.date\n        )\n        const result = await this.api.deleteNote(op.data.context, op.data.date)\n        console.log('[Sync] API deleteNote result:', result)\n        return result\n\n      case 'create-context':\n        console.log('[Sync] Calling API createContext')\n        return await this.api.createContext(op.data)\n\n      default:\n        throw new Error('Unknown operation type')\n    }\n  }\n\n  getPendingCount(): number {\n    return this.queue.length\n  }\n\n  clear(): void {\n    this.queue = []\n    this.failedOperations.clear()\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer)\n      this.batchTimer = null\n    }\n    this.updateUI()\n  }\n\n  // Get statistics for debugging\n  getStats(): SyncStats {\n    return {\n      queueSize: this.queue.length,\n      processing: this.processing,\n      failedOperations: this.failedOperations.size,\n      retryDelay: this.retryDelay\n    }\n  }\n}\n"],"names":["state","exports","_state","_listeners","_computed","constructor","this","currentUser","userSettings","theme","weekStart","timezone","dateFormat","uniqueContextMode","showBreadcrumb","showMarkdownEditor","hideNewContextButton","hasNoContexts","selectedContext","selectedDate","contexts","notes","notesWithDates","currentCalendarMonth","Date","getMonth","currentCalendarYear","getFullYear","isLoggingOut","syncStatus","pending","syncing","serverTimeOffset","Map","get","key","has","set","value","oldValue","_notify","update","changes","Object","entries","forEach","subscribe","callback","Set","add","listeners","delete","subscribeMany","keys","unsubscribers","map","unsub","computed","fn","getState","newValue","error","console","wildcardListeners","s","now","parts","Intl","DateTimeFormat","timeZone","year","month","day","formatToParts","find","p","type","window","__STATE__","db","dbName","version","pendingWrites","writeTimer","BATCH_DELAY","init","Promise","resolve","reject","request","indexedDB","open","onerror","onsuccess","result","onupgradeneeded","e","target","objectStoreNames","contains","createObjectStore","keyPath","saveNote","note","id","context","date","_localTimestamp","_cachedAt","updated_at","toISOString","scheduleBatchWrite","clearTimeout","setTimeout","flushPendingWrites","size","notesToWrite","Array","from","values","clear","tx","transaction","store","objectStore","put","oncomplete","log","length","saveNoteImmediate","getNote","saveNotes","getNotesByContext","getAll","allNotes","filter","n","saveContexts","isArray","warn","ctx","getContexts","deleteNote","EventBus","EventTarget","emit","eventName","detail","dispatchEvent","CustomEvent","on","listener","addEventListener","removeEventListener","once","handler","event","events","EVENT","NOTE_CACHED","NOTE_LOADED","NOTE_SAVED","NOTE_CHANGED","SYNC_STATUS","OPERATION_SYNCED","SYNC_ERROR","CONTEXT_CHANGED","CONTEXTS_LOADED","DATE_CHANGED","SHOW_ERROR","SHOW_SUCCESS","api","queue","processing","retryDelay","maxRetryDelay","batchTimer","batchDelay","failedOperations","maxRetries","operation","data","existingIndex","findIndex","op","Math","random","push","beforeLength","removedCount","processImmediate","updateUI","scheduleBatch","process","opKey","getOperationKey","executeOperation","shift","operationId","String","err","Error","message","includes","retryCount","maxRetriesReached","min","createContext","getPendingCount","getStats","queueSize"],"mappings":"wEA4LO,MAAMA,EAAAC,EAAA,IAAQ,IArJrB,MACUC,OACAC,WACAC,UAERC,WAAAA,GACEC,KAAKJ,OAAS,CAEZK,YAAa,KACbC,aAAc,CACZC,MAAO,OACPC,UAAW,EACXC,SAAU,MACVC,WAAY,WACZC,mBAAmB,EACnBC,gBAAgB,EAChBC,oBAAoB,EACpBC,sBAAsB,GAExBC,eAAe,EAGfC,gBAAiB,KACjBC,aAAc,KAGdC,SAAU,GACVC,MAAO,GACPC,eAAgB,GAGhBC,sBAAA,IAA0BC,MAAOC,WACjCC,qBAAA,IAAyBF,MAAOG,cAGhCC,cAAc,EACdC,WAAY,CAAEC,QAAS,EAAGC,SAAS,GAGnCC,iBAAkB,GAGpB1B,KAAKH,eAAiB8B,IACtB3B,KAAKF,cAAgB6B,GACvB,CAMAC,GAAAA,CAAIC,GACF,OAAI7B,KAAKF,UAAUgC,IAAID,GACd7B,KAAKF,UAAU8B,IAAIC,EAAnB7B,CAAyBA,KAAKJ,QAEhCI,KAAKJ,OAAOiC,EACrB,CAKAE,GAAAA,CAAwBF,EAAQG,GAC9B,MAAMC,EAAWjC,KAAKJ,OAAOiC,GACzBI,IAAaD,IAEjBhC,KAAKJ,OAAOiC,GAAOG,EACnBhC,KAAKkC,QAAQL,EAAKG,EAAOC,GAC3B,CAKAE,MAAAA,CAAOC,GACLC,OAAOC,QAAQF,GAASG,QAAQ,EAAEV,EAAKG,MACrChC,KAAK+B,IAAIF,EAAiBG,IAE9B,CAOAQ,SAAAA,CAAUX,EAAqBY,GAO7B,OANKzC,KAAKH,WAAWiC,IAAID,IACvB7B,KAAKH,WAAWkC,IAAIF,EAAK,IAAIa,KAE/B1C,KAAKH,WAAW+B,IAAIC,GAAMc,IAAIF,GAGvB,KACL,MAAMG,EAAY5C,KAAKH,WAAW+B,IAAIC,GAClCe,GACFA,EAAUC,OAAOJ,GAGvB,CAKAK,aAAAA,CAAcC,EAAkBN,GAC9B,MAAMO,EAAgBD,EAAKE,IAAIpB,GAAO7B,KAAKwC,UAAUX,EAAKY,IAC1D,MAAO,IAAMO,EAAcT,QAAQW,GAASA,IAC9C,CAKAC,QAAAA,CAAYtB,EAAauB,GACvBpD,KAAKF,UAAUiC,IAAIF,EAAKuB,EAC1B,CAKAC,QAAAA,GACE,MAAO,IAAKrD,KAAKJ,OACnB,CAKQsC,OAAAA,CAA4BL,EAAQyB,EAAuBrB,GACjE,MAAMW,EAAY5C,KAAKH,WAAW+B,IAAIC,GAClCe,GACFA,EAAUL,QAAQE,IAChB,IACIA,EAA8Ba,EAAUrB,EAC5C,OAASsB,GACPC,QAAQD,MAAM,gCAAgC1B,MAAS0B,EACzD,IAKJ,MAAME,EAAoBzD,KAAKH,WAAW+B,IAAI,KAC1C6B,GACFA,EAAkBlB,QAAQE,IACxB,IACIA,EAA8BZ,EAAKyB,EAAiBrB,EACxD,OAASsB,GACPC,QAAQD,MAAM,oCAAqCA,EACrD,GAGN,IAOF7D,EAAMyD,SAAS,QAAUO,IACvB,MAAMrD,EAAWqD,EAAExD,aAAaG,UAAY,MACtCsD,EAAM,IAAIzC,KAAKA,KAAKyC,MAAQD,EAAEhC,kBAS9BkC,EAPY,IAAIC,KAAKC,eAAe,QAAS,CACjDC,SAAU1D,EACV2D,KAAM,UACNC,MAAO,UACPC,IAAK,YAGiBC,cAAcR,GAKtC,MAAO,GAJMC,EAAMQ,QAAqB,SAAXC,EAAEC,MAAkBtC,SACnC4B,EAAMQ,QAAqB,UAAXC,EAAEC,MAAmBtC,SACvC4B,EAAMQ,QAAqB,QAAXC,EAAEC,MAAiBtC,UAM3B,oBAAXuC,SACPA,OAAeC,UAAY9E,GC0ClBC,EAAA,IAAQ,IA7Od,MACG8E,GAAyB,KACzBC,OAAS,eACTC,QAAU,EAGVC,kBAAoBjD,IACpBkD,WAA4B,KACnBC,YAAc,IAE/B,UAAMC,GACJ,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAUC,UAAUC,KAAKrF,KAAK0E,OAAQ1E,KAAK2E,SAEjDQ,EAAQG,QAAU,IAAMJ,EAAOC,EAAQ5B,OAEvC4B,EAAQI,UAAY,KAClBvF,KAAKyE,GAAKU,EAAQK,OAClBP,KAGFE,EAAQM,gBAAmBC,IACzB,MAAMjB,EAAMiB,EAAEC,OAA4BH,OAErCf,EAAGmB,iBAAiBC,SAAS,UAChCpB,EAAGqB,kBAAkB,QAAS,CAAEC,QAAS,OAGtCtB,EAAGmB,iBAAiBC,SAAS,aAChCpB,EAAGqB,kBAAkB,WAAY,CAAEC,QAAS,SAIpD,CAEA,cAAMC,CAASC,GACb,IAAKjG,KAAKyE,GAAI,OAEd,MAAMyB,EAAK,GAAGD,EAAKE,WAAWF,EAAKG,OAGnCpG,KAAK4E,cAAc7C,IAAImE,EAAI,IACtBD,EACHC,KACAG,gBAAiBnF,KAAKyC,MACtB2C,UAAWpF,KAAKyC,MAChB4C,WAAYN,EAAKM,aAAA,IAAkBrF,MAAOsF,gBAI5CxG,KAAKyG,oBACP,CAEQA,kBAAAA,GACFzG,KAAK6E,YACP6B,aAAa1G,KAAK6E,YAGpB7E,KAAK6E,WAAaN,OAAOoC,WAAW,KAClC3G,KAAK4G,sBACJ5G,KAAK8E,YACV,CAEA,wBAAc8B,GACZ,IAAK5G,KAAKyE,IAAkC,IAA5BzE,KAAK4E,cAAciC,KAAY,OAE/C,MAAMC,EAAeC,MAAMC,KAAKhH,KAAK4E,cAAcqC,UACnDjH,KAAK4E,cAAcsC,QAEnB,MAAMC,EAAKnH,KAAKyE,GAAG2C,YAAY,CAAC,SAAU,aACpCC,EAAQF,EAAGG,YAAY,SAM7B,OAJAR,EAAavE,QAAQ0D,IACnBoB,EAAME,IAAItB,KAGL,IAAIjB,QAAQ,CAACC,EAASC,KAC3BiC,EAAGK,WAAa,KACdhE,QAAQiE,IAAI,uBAAuBX,EAAaY,kBAChDzC,KAEFkC,EAAG7B,QAAU,IAAMJ,EAAOiC,EAAG5D,QAEjC,CAGA,uBAAMoE,CAAkB1B,GACtB,IAAKjG,KAAKyE,GAAI,OAEd,MAAM0C,EAAKnH,KAAKyE,GAAG2C,YAAY,CAAC,SAAU,aACpCC,EAAQF,EAAGG,YAAY,SACvBpB,EAAK,GAAGD,EAAKE,WAAWF,EAAKG,OAUnC,OARAiB,EAAME,IAAI,IACLtB,EACHC,KACAG,gBAAiBnF,KAAKyC,MACtB2C,UAAWpF,KAAKyC,MAChB4C,WAAYN,EAAKM,aAAA,IAAkBrF,MAAOsF,oBAGjCxB,QAAQ,CAACC,EAASC,KAC3BiC,EAAGK,WAAa,IAAMvC,IACtBkC,EAAG7B,QAAU,IAAMJ,EAAOiC,EAAG5D,QAEjC,CAEA,aAAMqE,CAAQzB,EAAiBC,GAC7B,IAAKpG,KAAKyE,GAAI,OAAO,KAErB,MACM4C,EADKrH,KAAKyE,GAAG2C,YAAY,CAAC,SAAU,YACzBE,YAAY,SACvBpB,EAAK,GAAGC,KAAWC,IAEzB,OAAO,IAAIpB,QAASC,IAClB,MAAME,EAAUkC,EAAMzF,IAAIsE,GAC1Bf,EAAQI,UAAY,IAAMN,EAAQE,EAAQK,QAAU,MACpDL,EAAQG,QAAU,IAAML,EAAQ,OAEpC,CAEA,eAAM4C,CAAU9G,GACd,IAAKf,KAAKyE,GAAI,OAEd,MAAM0C,EAAKnH,KAAKyE,GAAG2C,YAAY,CAAC,SAAU,aACpCC,EAAQF,EAAGG,YAAY,SACvB3D,EAAMzC,KAAKyC,MAajB,OAXA5C,EAAMwB,QAAQ0D,IACZ,MAAMC,EAAK,GAAGD,EAAKE,WAAWF,EAAKG,OACnCiB,EAAME,IAAI,IACLtB,EACHC,KACAG,gBAAiB1C,EACjB2C,UAAW3C,EACX4C,WAAYN,EAAKM,aAAA,IAAkBrF,MAAOsF,sBAInCxB,QAAQ,CAACC,EAASC,KAC3BiC,EAAGK,WAAa,IAAMvC,IACtBkC,EAAG7B,QAAU,IAAMJ,EAAOiC,EAAG5D,QAEjC,CAEA,uBAAMuE,CAAkB3B,GACtB,IAAKnG,KAAKyE,GAAI,MAAO,GAErB,MACM4C,EADKrH,KAAKyE,GAAG2C,YAAY,CAAC,SAAU,YACzBE,YAAY,SAE7B,OAAO,IAAItC,QAASC,IAClB,MAAME,EAAUkC,EAAMU,SACtB5C,EAAQI,UAAY,KAClB,MAAMyC,EAAW7C,EAAQK,QAAU,GACnCP,EAAQ+C,EAASC,OAAOC,GAAKA,EAAE/B,UAAYA,KAE7ChB,EAAQG,QAAU,IAAML,EAAQ,KAEpC,CAEA,kBAAMkD,CAAarH,GACjB,IAAKd,KAAKyE,GAAI,OAGd,IAAK3D,IAAaiG,MAAMqB,QAAQtH,GAE9B,YADA0C,QAAQ6E,KAAK,qDAAsDvH,GAIrE,MAAMqG,EAAKnH,KAAKyE,GAAG2C,YAAY,CAAC,YAAa,aACvCC,EAAQF,EAAGG,YAAY,YAS7B,OAPAxG,EAASyB,QAAQ+F,IACfjB,EAAME,IAAI,IACLe,EACHjC,gBAAiBnF,KAAKyC,UAInB,IAAIqB,QAAQ,CAACC,EAASC,KAC3BiC,EAAGK,WAAa,IAAMvC,IACtBkC,EAAG7B,QAAU,IAAMJ,EAAOiC,EAAG5D,QAEjC,CAEA,iBAAMgF,GACJ,IAAKvI,KAAKyE,GAAI,MAAO,GAErB,MACM4C,EADKrH,KAAKyE,GAAG2C,YAAY,CAAC,YAAa,YAC5BE,YAAY,YAE7B,OAAO,IAAItC,QAASC,IAClB,MAAME,EAAUkC,EAAMU,SACtB5C,EAAQI,UAAY,IAAMN,EAAQE,EAAQK,QAAU,IACpDL,EAAQG,QAAU,IAAML,EAAQ,KAEpC,CAEA,gBAAMuD,CAAWrC,EAAiBC,GAChC,IAAKpG,KAAKyE,GAAI,OAEd,MAAMyB,EAAK,GAAGC,KAAWC,IAGzBpG,KAAK4E,cAAc/B,OAAOqD,GAE1B,MAAMiB,EAAKnH,KAAKyE,GAAG2C,YAAY,CAAC,SAAU,aAK1C,OAJcD,EAAGG,YAAY,SAEvBzE,OAAOqD,GAEN,IAAIlB,QAAQ,CAACC,EAASC,KAC3BiC,EAAGK,WAAa,KACdhE,QAAQiE,IAAI,yBAAyBvB,KACrCjB,KAEFkC,EAAG7B,QAAU,IAAMJ,EAAOiC,EAAG5D,QAEjC,CAEA,WAAM2D,GACJ,IAAKlH,KAAKyE,GAAI,OAEd,MAAM0C,EAAKnH,KAAKyE,GAAG2C,YAAY,CAAC,QAAS,YAAa,aAKtD,OAHAD,EAAGG,YAAY,SAASJ,QACxBC,EAAGG,YAAY,YAAYJ,QAEpB,IAAIlC,QAAQ,CAACC,EAASC,KAC3BiC,EAAGK,WAAa,IAAMvC,IACtBkC,EAAG7B,QAAU,IAAMJ,EAAOiC,EAAG5D,QAEjC,ICpMF,MAAMkF,UAAiBC,YAIrBC,IAAAA,CAA0BC,EAAcC,GACtC7I,KAAK8I,cAAc,IAAIC,YAAYH,EAAW,CAAEC,WAClD,CAKAG,EAAAA,CACEJ,EACAnG,GAEA,MAAMwG,EAAWxG,EAEjB,OADAzC,KAAKkJ,iBAAiBN,EAAWK,GAC1B,IAAMjJ,KAAKmJ,oBAAoBP,EAAWK,EACnD,CAKAG,IAAAA,CACER,EACAnG,GAEA,MAAMwG,EAAWxG,EACX4G,EAAWC,IACfL,EAASK,GACTtJ,KAAKmJ,oBAAoBP,EAAWS,IAGtC,OADArJ,KAAKkJ,iBAAiBN,EAAWS,GAC1B,IAAMrJ,KAAKmJ,oBAAoBP,EAAWS,EACnD,EAGK,MAAME,EAAA5J,EAAA,IAAS,IAAI8I,GAGbe,EAAA7J,EAAA,IAAQ,CAEnB8J,YAAa,cACbC,YAAa,cACbC,WAAY,aACZC,aAAc,eAGdC,YAAa,cACbC,iBAAkB,mBAClBC,WAAY,aAGZC,gBAAiB,kBACjBC,gBAAiB,kBAGjBC,aAAc,eAGdC,WAAY,aACZC,aAAc,iBC0IhBzK,EAAA,IAxOO,MACG0K,IACAC,MAAyB,GACzBC,YAAa,EACbC,WAAa,IACJC,cAAgB,IACzBC,WAAoC,KAC3BC,WAAa,KACtBC,qBAAuBjJ,IACdkJ,WAAa,EAE9B9K,WAAAA,CAAYsK,GACVrK,KAAKqK,IAAMA,CACb,CAEA1H,GAAAA,CAAImI,GAIF,GAHAtH,QAAQiE,IAAI,oCAAqCqD,EAAUxG,KAAMwG,EAAUC,MAGpD,cAAnBD,EAAUxG,KAAsB,CAClC,MAAM0G,EAAgBhL,KAAKsK,MAAMW,UAC/BC,GACc,cAAZA,EAAG5G,MACH4G,EAAGH,KAAK5E,UAAY2E,EAAUC,KAAK5E,SACnC+E,EAAGH,KAAK3E,OAAS0E,EAAUC,KAAK3E,OAGd,IAAlB4E,GAEFhL,KAAKsK,MAAMU,GAAiB,IAAKF,EAAW5E,GAAIhF,KAAKyC,MAAQwH,KAAKC,UAClE5H,QAAQiE,IAAI,qDAEZzH,KAAKsK,MAAMe,KAAK,IAAKP,EAAW5E,GAAIhF,KAAKyC,MAAQwH,KAAKC,WACtD5H,QAAQiE,IAAI,4CAEhB,KAAA,IAA8B,gBAAnBqD,EAAUxG,KAAwB,CAE3C,MAAMgH,EAAetL,KAAKsK,MAAM5C,OAChC1H,KAAKsK,MAAQtK,KAAKsK,MAAMrC,OACtBiD,KAEgB,cAAZA,EAAG5G,MACH4G,EAAGH,KAAK5E,UAAY2E,EAAUC,KAAK5E,SACnC+E,EAAGH,KAAK3E,OAAS0E,EAAUC,KAAK3E,OAGtC,MAAMmF,EAAeD,EAAetL,KAAKsK,MAAM5C,OAW/C,OAVI6D,EAAe,GACjB/H,QAAQiE,IAAI,kBAAkB8D,2CAGhCvL,KAAKsK,MAAMe,KAAK,IAAKP,EAAW5E,GAAIhF,KAAKyC,MAAQwH,KAAKC,WACtD5H,QAAQiE,IAAI,0CAGZjE,QAAQiE,IAAI,iEACZzH,KAAKwL,kBAEP,CACExL,KAAKsK,MAAMe,KAAK,IAAKP,EAAW5E,GAAIhF,KAAKyC,MAAQwH,KAAKC,WACtD5H,QAAQiE,IAAI,kCACd,CAEAjE,QAAQiE,IAAI,qBAAsBzH,KAAKsK,MAAM5C,QAC7C1H,KAAKyL,WACLzL,KAAK0L,eACP,CAEQA,aAAAA,GAEF1L,KAAK0K,YACPhE,aAAa1G,KAAK0K,YAIpBlH,QAAQiE,IAAI,yCAAyCzH,KAAK2K,gBAC1D3K,KAAK0K,WAAa/D,WAAW,KAC3BnD,QAAQiE,IAAI,kDACZzH,KAAK2L,WACJ3L,KAAK2K,WACV,CAEAa,gBAAAA,GAEMxL,KAAK0K,aACPhE,aAAa1G,KAAK0K,YAClB1K,KAAK0K,WAAa,MAIpBlH,QAAQiE,IAAI,uCACZzH,KAAKyL,WACLzL,KAAK2L,SACP,CAEQF,QAAAA,GACN,MAAMjK,EAAUxB,KAAKsK,MAAM5C,OAC3B6B,EAAOZ,KAAKa,EAAMK,YAAa,CAC7BrI,UACAC,QAASzB,KAAKuK,YAElB,CAEA,aAAMoB,GACJ,IAAI3L,KAAKuK,YAAoC,IAAtBvK,KAAKsK,MAAM5C,OAAlC,CAMA,IAJA1H,KAAKuK,YAAa,EAClBvK,KAAK0K,WAAa,KAClB1K,KAAKyL,WAEEzL,KAAKsK,MAAM5C,OAAS,GAAG,CAC5B,MAAMwD,EAAKlL,KAAKsK,MAAM,GACtB,IAAKY,EAAI,MAET,MAAMU,EAAQ5L,KAAK6L,gBAAgBX,GAEnC,UACQlL,KAAK8L,iBAAiBZ,GAG5BlL,KAAKsK,MAAMyB,QACX/L,KAAK4K,iBAAiB/H,OAAO+I,GAE7BrC,EAAOZ,KAAKa,EAAMM,iBAAkB,CAAEkC,YAAaC,OAAOf,EAAGhF,IAAM0F,KACnEpI,QAAQiE,IAAI,8BAA+ByD,EAAG5G,KAAMsH,GACpD5L,KAAKyL,WAGLzL,KAAKwK,WAAa,GACpB,OAAS0B,GACP,MAAM3I,EAAQ2I,aAAeC,MAAQD,EAAM,IAAIC,MAAMF,OAAOC,IAI5D,GAHA1I,QAAQ6E,KAAK,mCAAoC9E,GAG7CA,EAAM6I,QAAQC,SAAS,mBAAoB,CAC7C7I,QAAQiE,IAAI,iEAEZ,KACF,CAGA,MAAM6E,GAActM,KAAK4K,iBAAiBhJ,IAAIgK,IAAU,GAAK,EAC7D5L,KAAK4K,iBAAiB7I,IAAI6J,EAAOU,GAE7BA,GAActM,KAAK6K,YAErBrH,QAAQD,MAAM,uBAAuBvD,KAAK6K,qCAAsCe,GAChF5L,KAAKsK,MAAMyB,QACX/L,KAAK4K,iBAAiB/H,OAAO+I,GAE7BrC,EAAOZ,KAAKa,EAAMO,WAAY,CAC5BqC,QAAS7I,EAAM6I,QACfG,mBAAmB,MAIrB/I,QAAQiE,IAAI,gBAAgB6E,KAActM,KAAK6K,4BAA6Be,GAC5ErC,EAAOZ,KAAKa,EAAMO,WAAY,CAC5BqC,QAAS7I,EAAM6I,QACfE,aACAzB,WAAY7K,KAAK6K,mBAGb,IAAI7F,QAAQC,GAAW0B,WAAW1B,EAASjF,KAAKwK,aACtDxK,KAAKwK,WAAaW,KAAKqB,IAAsB,IAAlBxM,KAAKwK,WAAkBxK,KAAKyK,eAE3D,CACF,CAEAzK,KAAKuK,YAAa,EAClBvK,KAAKwK,WAAa,IAClBxK,KAAKyL,UAnE2C,CAoElD,CAEQI,eAAAA,CAAgBX,GACtB,MAAgB,cAAZA,EAAG5G,MAAoC,gBAAZ4G,EAAG5G,KACzB,GAAG4G,EAAG5G,QAAQ4G,EAAGH,KAAK5E,WAAW+E,EAAGH,KAAK3E,OAE3C,GAAG8E,EAAG5G,QAAQ4G,EAAGhF,IAC1B,CAEA,sBAAc4F,CAAiBZ,GAG7B,OAFA1H,QAAQiE,IAAI,8BAA+ByD,EAAG5G,KAAM4G,EAAGH,MAE/CG,EAAG5G,MACT,IAAK,YAEH,OADAd,QAAQiE,IAAI,qCACCzH,KAAKqK,IAAIrE,SAASkF,EAAGH,MAEpC,IAAK,cACHvH,QAAQiE,IACN,8CACAyD,EAAGH,KAAK5E,QACR,QACA+E,EAAGH,KAAK3E,MAEV,MAAMZ,QAAexF,KAAKqK,IAAI7B,WAAW0C,EAAGH,KAAK5E,QAAS+E,EAAGH,KAAK3E,MAElE,OADA5C,QAAQiE,IAAI,gCAAiCjC,GACtCA,EAET,IAAK,iBAEH,OADAhC,QAAQiE,IAAI,0CACCzH,KAAKqK,IAAIoC,cAAcvB,EAAGH,MAEzC,QACE,UAAUoB,MAAM,0BAEtB,CAEAO,eAAAA,GACE,OAAO1M,KAAKsK,MAAM5C,MACpB,CAEAR,KAAAA,GACElH,KAAKsK,MAAQ,GACbtK,KAAK4K,iBAAiB1D,QAClBlH,KAAK0K,aACPhE,aAAa1G,KAAK0K,YAClB1K,KAAK0K,WAAa,MAEpB1K,KAAKyL,UACP,CAGAkB,QAAAA,GACE,MAAO,CACLC,UAAW5M,KAAKsK,MAAM5C,OACtB6C,WAAYvK,KAAKuK,WACjBK,iBAAkB5K,KAAK4K,iBAAiB/D,KACxC2D,WAAYxK,KAAKwK,WAErB"}